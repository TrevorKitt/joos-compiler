Production rules. Epsilon denotes empty word. Words that start capitalized are terminals, the rest are non-terminals. Lastly
"|" denotes logical OR in choosing the grammar except for line 64:

InclusiveOrExpression -> ExclusiveOrExpression | InclusiveOrExpression | ExclusiveOrExpression
where InclusiveOrExpression | ExclusiveOrExpression is a single RHS

Please note that this language doesn't fully specify the requirements for Joos 1W and some things have to be checked
on a later stage in the parsing process. For example:

	class A {}

Is illegal in Joos 1W as it would be private to the package and Joos 1W doesn't have private package classes. However
	
	public class A {}

Is legal in Joos 1W

In reviewing this grammar please go over the specifications here:
https://www.student.cs.uwaterloo.ca/~cs444/joos.html

This grammar is derived from:
http://www.cs.cornell.edu/andru/javaspec/19.doc.html

Goal -> CompilationUnit
CompilationUnit -> PackageDeclaration* ImportDeclarations* TypeDeclarations*
PackageDeclaration* -> package Name ; | epsilon
ImportDeclarations* -> ImportDeclarations | epsilon
TypeDeclarations* -> TypeDeclaration | TypeDeclarations TypeDeclaration
ImportDeclarations -> ImportDeclaration | ImportDeclarations ImportDeclaration
ImportDeclaration -> SingleTypeImportDeclaration | TypeImportOnDemandDeclaration
SingleTypeImportDeclaration -> import Name ;
TypeImportOnDemandDeclaration -> import Name . * ;
TypeDeclaration -> ClassDeclaration | InterfaceDeclaration | ;
Name -> SimpleName | QualifiedName
SimpleName -> Identifier
QualifiedName -> Name . Identifier
Identifier -> IdentifierChars but not a Keyword or BooleanLiteral or NullLiteral
IdentifierChars -> JavaLetter | IdentifierChars JavaLetterOrDigit
JavaLetter -> ASCII A-Z, a-z, _ or $
JavaLetterOrDigit -> ASCII A-Z, a-z, _, $ or 0-9
ClassDeclaration -> Modifiers class Identifier Super* Interfaces* ClassBody
Modifier -> public | abstract | final | static | native
Super* -> Super | epsilon
Super -> extends ClassType
ClassType -> ClassOrInterfaceType
ClassOrInterfaceType -> Name
Interfaces* -> Interfaces | epsilon
Interfaces -> implements InterfaceTypeList
InterfaceTypeList -> InterfaceType | InterfaceTypeList , InterfaceType
InterfaceType -> ClassOrInterfaceType
ClassBody -> { ClassBodyDeclarations* }
ClassBodyDeclarations -> ClassBodyDeclaration | ClassBodyDeclarations ClassBodyDeclaration
ClassBodyDeclaration -> ClassMemberDeclaration | ConstructorDeclaration
ClassMemberDeclaration -> FieldDeclaration | MethodDeclaration
FieldDeclaration -> Modifiers Type VariableDeclarator ;
Type -> PrimitiveType | ReferenceType
PrimitiveType -> byte | short | int | long | char | boolean
ReferenceType -> ClassOrInterfaceType | ArrayType
ArrayType -> PrimitiveType [ ] | Name [ ]
VariableDeclarator -> VariableDeclaratorId | Identifier = Expression
Expression -> ConditionalExpression | Assignment
Assignment -> LeftHandSide = AssignmentExpression
LeftHandSide -> Name | FieldAccess | ArrayAcces
FieldAccess -> Primary . Identifier
Primary -> PrimaryNoNewArray | ArrayCreationExpression
PrimaryNoNewArray -> Literal | this | ( Expression ) | ClassInstanceCreationExpression | FieldAccess | MethodInvocation | ArrayAccess
Literal -> A Number i.e 1234 | true | false | a char literal i.e 'a' | a string literal i.e "a" | null
ClassInstanceCreationExpression -> new ClassType ( ArgumentList* )
ArgumentList* -> ArgumentList | epsilon
ArgumentList -> Expression | ArgumentList , Expression
MethodInvocation -> Name ( ArgumentList* ) | Primary . Identifier ( ArgumentList* )
ArrayAccess -> Name [ Expression ] | PrimaryNoNewArray [ Expression ]
ArrayCreationExpression -> new PrimitiveType DimExprs Dims* | new ClassOrInterfaceType DimExprs Dims*
DimExprs -> DimExpr | DimExprs DimExpr
DimExpr -> [ Expression ]
Dims* -> [ ] | epsilon
AssignmentExpression -> ConditionalExpression | Assignment
ConditionalExpression -> ConditionalOrExpression
ConditionalOrExpression -> ConditionalAndExpression | ConditionalOrExpression || ConditionalAndExpression
ConditionalAndExpression -> InclusiveOrExpression | ConditionalAndExpression && InclusiveOrExpression
InclusiveOrExpression -> ExclusiveOrExpression | InclusiveOrExpression | ExclusiveOrExpression
ExclusiveOrExpression -> AndExpression | ExclusiveOrExpression ^ AndExpression
AndExpression -> EqualityExpression | AndExpression & EqualityExpression
EqualityExpression -> RelationalExpression | EqualityExpression == RelationalExpression | EqualityExpression != RelationalExpression
RelationalExpression -> ShiftExpression | RelationalExpression < AdditiveExpression | RelationalExpression > AdditiveExpression |
			RelationalExpression <= AdditiveExpression | RelationalExpression >= AdditiveExpression |
			RelationalExpression instanceof ReferenceType
AdditiveExpression -> MultiplicativeExpression | AdditiveExpression + MultiplicativeExpression |
		      AdditiveExpression - MultiplicativeExpression
MultiplicativeExpression -> UnaryExpression | MultiplicativeExpression * UnaryExpression | MultiplicativeExpression / UnaryExpression |
			    MultiplicativeExpression % UnaryExpression
UnaryExpression -> - UnaryExpression | UnaryExpressionNotPlusMinus
UnaryExpressionNotPlusMinus -> ! UnaryExpression | CastExpression | Primary | Name
CastExpression -> ( PrimitiveType Dims* ) UnaryExpression | ( Expression ) UnaryExpressionNotPlusMinus |
		  ( Name Dims* ) UnaryExpressionNotPlusMinus
MethodDeclaration -> MethodHeader MethodBody
MethodHeader -> Modifiers* Type MethodDeclarator | Modifiers* void MethodDeclarator
MethodDeclarator -> Identifier ( FormalParameterList* )
FormalParameterList* -> FormalParameter | FormalParameterList , FormalParameter
FormalParameter -> Type VariableDeclaratorId
MethodBody -> Block | ;
Block -> { BlockStatements* }
BlockStatements* -> BlockStatements | epsilon
BlockStatements -> BlockStatement | BlockStatements BlockStatement
BlockStatement -> LocalVariableDeclarationStatement | Statement
LocalVariableDeclarationStatement -> LocalVariableDeclaration ;
LocalVariableDeclaration -> Type VariableDeclarator
Statement -> StatementWithoutTrailingSubstatement | IfThenStatement | IfThenElseStatement | WhileStatement | ForStatement
StatementWithoutTrailingSubstatement -> Block | EmptyStatement | ExpressionStatement | ReturnStatement
EmptyStatement -> ;
ExpressionStatement -> StatementExpression ;
StatementExpression -> Assignment | MethodInvocation | ClassInstanceCreationExpression
IfThenStatement -> if ( Expression ) Statement
IfThenElseStatement -> if ( Expression ) StatementNoShortIf else Statement
StatementNoShortIf -> StatementWithoutTrailingSubstatement | IfThenElseStatementNoShortIf | WhileStatementNoShortIf | ForStatementNoShortIf
IfThenElseStatementNoShortIf -> if ( Expression ) StatementNoShortIf else StatementNoShortIf
WhileStatementNoShortIf -> while ( Expression ) StatementNoShortIf
ForStatementNoShortIf -> for ( ForInit* ; Expression* ; ForUpdate* ) StatementNoShortIf
WhileStatement -> while ( Expression ) Statement
ForStatement -> for ( ForInit* ; Expression* ; ForUpdate* ) Statement
ForInit* -> ForInit | epsilon
ForInit -> StatementExpression | LocalVariableDeclaration
ForUpdate* -> ForUpdate | epsilon
ForUpdate -> StatementExpression
ConstructorDeclaration -> Modifiers* ConstructorDeclarator ConstructorBody
ConstructorDeclarator -> SimpleName ( FormalParameterList* )
ConstructorBody -> { BlockStatements* }
InterfaceDeclaration -> Modifiers interface Identifier ExtendsInterfaces InterfaceBody
ExtendsInterfaces -> extends InterfaceType | ExtendsInterfaces , InterfaceType
InterfaceBody -> { InterfaceMemberDeclarations* }
InterfaceMemberDeclarations* -> InterfaceMemberDeclarations | epsilon
InterfaceMemberDeclarations -> InterfaceMemberDeclaration | InterfaceMemberDeclarations InterfaceMemberDeclaration
InterfaceMemberDeclaration -> ConstantDeclaration | AbstractMethodDeclaration
ConstantDeclaration -> FieldDeclaration
FieldDeclarationExceptConstant -> Modifiers Type VariableDeclarators ; 
